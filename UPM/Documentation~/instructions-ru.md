# E314.DI

## Описание

Модуль `E314.DI` содержит `DiContainer`.
`DiContainer` — это контейнер для внедрения зависимостей (DI), который помогает управлять созданием объектов и их зависимостями. В этом руководстве вы узнаете, как настроить контейнер, связать типы, разрешать зависимости и управлять их жизненным циклом.

## Содержание

- [E314.DI](#e314di)
  - [Описание](#описание)
  - [Содержание](#содержание)
  - [Основные понятия](#основные-понятия)
  - [Настройка контейнера](#настройка-контейнера)
  - [Создание связей (Bindings)](#создание-связей-bindings)
    - [Вложенные контейнеры](#вложенные-контейнеры)
    - [Типов с несколькими конструкторами](#типов-с-несколькими-конструкторами)
  - [Разрешение зависимостей](#разрешение-зависимостей)
  - [Управление жизненным циклом](#управление-жизненным-циклом)
    - [Transient (AsTransient)](#transient-astransient)
    - [Singleton (AsSingle)](#singleton-assingle)
    - [Scoped (AsScoped)](#scoped-asscoped)
  - [Рекомендации](#рекомендации)

## Основные понятия

**Dependency Injection (DI)** – это техника, позволяющая отделить создание объектов от их использования. Вместо того чтобы создавать зависимости внутри класса, они передаются (внедряются) извне.

**DI-контейнер** – это компонент, который:

- Управляет регистрацией (биндингом) типов и их реализаций.
- Создает объекты (инстансы) и внедряет в них зависимости.
- Обеспечивает управление жизненным циклом объектов (например, Singleton, Scoped, Transient).

**Связи (Bindings)** – это настройка, которая связывает ключевой тип (интерфейс или базовый класс) с конкретной реализацией или фабрикой. Методы, такие как `To<T>()`, `To(object instance)`, `ToSelf()` и `ToFactory<T>()`, позволяют задать способ создания объекта.

**Управление жизненным циклом** – позволяет определить, как долго объект будет жить в рамках контейнера:

- Singleton (AsSingle) – один экземпляр создаётся один раз для всего времени жизни контейнера.
- Scoped (AsScoped) – объект создаётся один раз для каждой области (scope). При использовании вложенных контейнеров сначала проверяется наличие биндинга в текущем (дочернем) контейнере, и только если там его нет – используется биндинг из родительского.
- Transient (AsTransient) – новый экземпляр создаётся каждый раз при разрешении зависимости.

## Настройка контейнера

Контейнер создаётся с помощью конструктора класса `DiContainer`. Можно задать конфигурацию, например, начальную вместимость для общих и scoped объектов:

``` csharp
// Пример настройки DiContainer с конфигурацией
var config = new DiContainer.Config(capacity: 100, scopeCapacity: 5);
var container = new DiContainer(config);
```

В этом примере задаются начальные значения для основных и scoped объектов.

## Создание связей (Bindings)

После создания контейнера необходимо зарегистрировать зависимости.
Для этого используются методы `Bind<T>()` или `Bind(Type type)`, а затем цепочка вызовов для настройки создания объектов:

``` csharp
// Регистрация зависимости с использованием реализации
container.Bind<IMyService>().To<MyService>();

// Регистрация зависимости для самого типа (ToSelf)
container.Bind<MyService>().ToSelf();

// Регистрация конкретного экземпляра
var instance = new MyService();
container.Bind<IMyService>().To(instance);

// Регистрация зависимости через фабрику
container.Bind<IMyService>().ToFactory<MyServiceFactory>();
```

### Вложенные контейнеры

Каждая такая регистрация связывает интерфейс или тип с реализацией, которая будет использоваться при разрешении зависимостей.

Предположим, у нас есть родительский контейнер с некоторым набором биндингов.
При создании дочернего контейнера можно переопределить некоторые биндинги.
При разрешении зависимости сначала проверяется текущий (дочерний) контейнер, и только затем – родительский.

``` csharp
// Создаем родительский контейнер и регистрируем биндинг
var parentContainer = new DiContainer();
parentContainer.Bind<IMyService>().To<MyService>();

// Создаем дочерний контейнер, который может использовать родительский биндинг,
// но имеет возможность переопределить его
var childContainer = new DiContainer(parentContainer);
childContainer.Bind<IMyService>().To<MyServiceAlternative>();

// Разрешение в родительском контейнере вернет экземпляр MyService:
IMyService parentService = parentContainer.Resolve<IMyService>();

// Разрешение в дочернем контейнере сначала ищет биндинг в childContainer и находит MyServiceAlternative:
IMyService childService = childContainer.Resolve<IMyService>();

// Таким образом, биндинги в дочернем контейнере имеют приоритет перед родительскими.
```

### Типов с несколькими конструкторами

При регистрации типов с несколькими конструкторами контейнер использует специальный механизм для выбора конструктора, который будет вызван при создании экземпляра:

- **Единичный конструктор** - Если у типа объявлен только один конструктор, он автоматически используется для создания объекта.
- **Анализ нескольких конструкторов** - При наличии более одного конструктора контейнер выполняет следующий алгоритм:
  - Атрибут `[Inject]`: Если один из конструкторов помечен атрибутом `[Inject]`, именно он будет выбран как основной для инстанцирования.
  - Множественные `[Inject]`: Если обнаружено более одного конструктора с атрибутом `[Inject]`, система выбрасывает исключение, так как не может однозначно определить приоритетный конструктор.
  - Отсутствие `[Inject]`: Если ни один из конструкторов не помечен атрибутом, выбирается первый конструктор из списка доступных.

Такой подход позволяет явно указать, какой конструктор следует использовать (через `[Inject]`), что особенно полезно, если в классе присутствуют конструкторы с разным набором параметров или уровнем сложности внедрения зависимостей. Это помогает избежать неоднозначностей при разрешении зависимостей и обеспечивает корректное создание объектов в контейнере.

## Разрешение зависимостей

После регистрации зависимостей контейнер может создавать объекты и внедрять их зависимости через конструктор.
Пример разрешения зависимости:

``` csharp
// Разрешение зависимости через универсальный метод Resolve<T>()
IMyService service = container.Resolve<IMyService>();

// Разрешение с использованием типа
object serviceObj = container.Resolve(typeof(IMyService));
```

Контейнер при вызове Resolve ищет зарегистрированный биндинг.
Если тип представляет коллекцию (`IEnumerable<T>` или `IReadOnlyList<T>`), контейнер собирает все зарегистрированные реализации.

## Управление жизненным циклом

Контейнер позволяет задавать время жизни для объектов. Рассмотрим основные варианты:

### Transient (AsTransient)

Метод `AsTransient()` позволяет каждый раз создавать новый экземпляр объекта при разрешении зависимости.

``` csharp
container.Bind<IMyService>().To<MyService>().AsTransient();
```

### Singleton (AsSingle)

Метод `AsSingle()` гарантирует, что создаётся только один экземпляр для всех запросов:

``` csharp
container.Bind<IMyService>().To<MyService>().AsSingle();
```

### Scoped (AsScoped)

Метод `AsScoped()` создаёт новый экземпляр для каждого скоупа контейнера. Это особенно важно при работе с вложенными контейнерами.

Если в дочернем контейнере не зарегистрирована своя связь, он может использовать связь из родительского (через переданный `IBindingProvider`), но кэшировать результат он будет локально. Это означает, что даже если родительский контейнер имеет зарегистрированную зависимость с режимом `Scoped`, при разрешении в дочернем контейнере будет создан новый экземпляр и сохранён в кэше дочернего контейнера.

Пример работы с `AsScoped` и вложенными контейнерами:

``` csharp
// Создаем родительский контейнер и регистрируем зависимость с режимом Scoped.
var parentContainer = new DiContainer();
parentContainer.Bind<IScopedService>().To<ScopedService>().AsScoped();

// Создаем дочерний контейнер, используя родительский как провайдер связей.
var childContainer = new DiContainer(bindingProvider: parentContainer);

// Разрешаем зависимость в родительском контейнере.
var serviceFromParent = parentContainer.Resolve<IScopedService>();

// Разрешаем зависимость в дочернем контейнере.
// Несмотря на то, что связь берется из родителя, кэширование происходит отдельно.
var serviceFromChild = childContainer.Resolve<IScopedService>();

// serviceFromParent и serviceFromChild будут разными экземплярами.
```

Такой подход позволяет изолировать области и избежать непреднамеренного разделения состояния между различными частями приложения.

## Рекомендации

- **Планируйте время жизни объектов**: Используйте `AsSingle` для сервисов, состояние которых должно быть единым на все приложение, `AsScoped` – для создания экземпляров, зависящих от контекста, а `AsTransient` – для легковесных или временных объектов.
- **Избегайте конфликтов биндингов**: При использовании нескольких контейнеров помните, что дочерний контейнер проверяет свои биндинги в первую очередь. Это позволяет переопределять зависимости локально, но требует тщательного управления регистрацией.
- **Правильное освобождение ресурсов**: `DiContainer` реализует `IDisposable`, поэтому по завершении работы контейнера следует корректно освобождать ресурсы.
- **Централизованная регистрация**: Регистрируйте все зависимости в одном месте, чтобы упростить сопровождение и тестирование.
- **Минимизация дублирования**: Избегайте дублирования регистраций и внимательно следите за конфликтами при наличии нескольких контейнеров или провайдеров связей.
